package com.ucombinator.dalvik.analysis

import com.ucombinator.dalvik.AST._

class IntraproceduralAnalyzer(classes: Array[ClassDef]) extends SimpleMethodCallGraph(classes: Array[ClassDef]) {
  // Maybe I should subclass Method and have the subclass keep track of the list of methods it calls?
  // If I did, I'd probably also keep track of inputs (globals accessed, etc.), outputs, and the influence graph
  // that would demonstrate which inputs influence which outputs
  private val callGraph: Map[Method, List[Method]] = Map.empty
  
//  private def makeLabelTable()
  
  private def next(s: State): Boolean = { // TODO: should be Set[State] = {
    val insn = s.statements.head
    insn match {
      case End => false
      case Nop => false
      case Move(a, b) => false
      case MoveWide(a, b) => false
      case MoveObject(a, b) => false
      case MoveResult(a) => false
      case MoveResultWide(a) => false
      case MoveResultObject(a) => false
      case MoveException(a) => false
      case MoveFrom16(a, b) => false
      case MoveWideFrom16(a, b) => false
      case MoveObjectFrom16(a, b) => false
      case Move16(a, b) => false
      case MoveWide16(a, b) => false
      case MoveObject16(a, b) => false
      case ReturnVoid => false
      case Return(a) => false
      case ReturnWide(a) => false
      case ReturnObject(a) => false
      case InvokeSuper(args, b) => false
      case InvokeDirect(args, b) => false
      case InvokeStatic(args, b) => false
      case InvokeInterface(args, b) => false
      case InvokeVirtual(args, b) => false
      case InvokeVirtualRange(c, a, b) => false
      case InvokeSuperRange(c, a, b) => false
      case InvokeDirectRange(c, a, b) => false
      case InvokeStaticRange(c, a, b) => false
      case InvokeInterfaceRange(c, a, b) => false
      case Goto(a) => false
      case Goto16(a) => false
      case Goto32(a) => false
      case IfEqz(a, b) => false
      case IfNez(a, b) => false
      case IfLtz(a, b) => false
      case IfGez(a, b) => false
      case IfGtz(a, b) => false
      case IfLez(a, b) => false
      case IfEq(a, b, c) => false
      case IfNe(a, b, c) => false
      case IfLt(a, b, c) => false
      case IfGe(a, b, c) => false
      case IfGt(a, b, c) => false
      case IfLe(a, b, c) => false
      case PackedSwitch(a, firstKey, targets) => false
      case TempPackedSwitch(a, b) => false
      case SparseSwitch(a, keys, targets) => false
      case TempSparseSwitch(a, b) => false
      case Throw(a) => false
      case MonitorEnter(a) => false
      case MonitorExit(a) => false
      case CmplFloat(a, b, c) => false
      case CmpgFloat(a, b, c) => false
      case CmplDouble(a, b, c) => false
      case CmpgDouble(a, b, c) => false
      case CmpLong(a, b, c) => false
      case Const4(a, b) => false
      case Const16(a, b) => false
      case Const(a, b) => false
      case ConstHigh16(a, b) => false
      case ConstWide16(a, b) => false
      case ConstWide32(a, b) => false
      case ConstWide(a, b) => false
      case ConstWideHigh16(a, b) => false
      case ConstString(a, b) => false
      case ConstStringJumbo(a, b) => false
      case ConstClass(a, b) => false
      case NegInt(a, b) => false
      case NegLong(a, b) => false
      case NegFloat(a, b) => false
      case NegDouble(a, b) => false
      case NotInt(a, b) => false
      case NotLong(a, b) => false
      case IntToLong(a, b) => false
      case IntToFloat(a, b) => false
      case IntToDouble(a, b) => false
      case LongToInt(a, b) => false
      case LongToFloat(a, b) => false
      case LongToDouble(a, b) => false
      case FloatToInt(a, b) => false
      case FloatToLong(a, b) => false
      case FloatToDouble(a, b) => false
      case DoubleToInt(a, b) => false
      case DoubleToLong(a, b) => false
      case DoubleToFloat(a, b) => false
      case IntToByte(a, b) => false
      case IntToChar(a, b) => false
      case IntToShort(a, b) => false
      case AddInt2Addr(a, b) => false
      case SubInt2Addr(a, b) => false
      case MulInt2Addr(a, b) => false
      case DivInt2Addr(a, b) => false
      case RemInt2Addr(a, b) => false
      case AndInt2Addr(a, b) => false
      case OrInt2Addr(a, b) => false
      case XorInt2Addr(a, b) => false
      case ShlInt2Addr(a, b) => false
      case ShrInt2Addr(a, b) => false
      case UshrInt2Addr(a, b) => false
      case AddLong2Addr(a, b) => false
      case SubLong2Addr(a, b) => false
      case MulLong2Addr(a, b) => false
      case DivLong2Addr(a, b) => false
      case RemLong2Addr(a, b) => false
      case AndLong2Addr(a, b) => false
      case OrLong2Addr(a, b) => false
      case XorLong2Addr(a, b) => false
      case ShlLong2Addr(a, b) => false
      case ShrLong2Addr(a, b) => false
      case UshrLong2Addr(a, b) => false
      case AddFloat2Addr(a, b) => false
      case SubFloat2Addr(a, b) => false
      case MulFloat2Addr(a, b) => false
      case DivFloat2Addr(a, b) => false
      case RemFloat2Addr(a, b) => false
      case AddDouble2Addr(a, b) => false
      case SubDouble2Addr(a, b) => false
      case MulDouble2Addr(a, b) => false
      case DivDouble2Addr(a, b) => false
      case RemDouble2Addr(a, b) => false
      case AddInt(a, b, c) => false
      case SubInt(a, b, c) => false
      case MulInt(a, b, c) => false
      case DivInt(a, b, c) => false
      case RemInt(a, b, c) => false
      case AndInt(a, b, c) => false
      case OrInt(a, b, c) => false
      case XorInt(a, b, c) => false
      case ShlInt(a, b, c) => false
      case ShrInt(a, b, c) => false
      case UshrInt(a, b, c) => false
      case AddLong(a, b, c) => false
      case SubLong(a, b, c) => false
      case MulLong(a, b, c) => false
      case DivLong(a, b, c) => false
      case RemLong(a, b, c) => false
      case AndLong(a, b, c) => false
      case OrLong(a, b, c) => false
      case XorLong(a, b, c) => false
      case ShlLong(a, b, c) => false
      case ShrLong(a, b, c) => false
      case UshrLong(a, b, c) => false
      case AddFloat(a, b, c) => false
      case SubFloat(a, b, c) => false
      case MulFloat(a, b, c) => false
      case DivFloat(a, b, c) => false
      case RemFloat(a, b, c) => false
      case AddDouble(a, b, c) => false
      case SubDouble(a, b, c) => false
      case MulDouble(a, b, c) => false
      case DivDouble(a, b, c) => false
      case RemDouble(a, b, c) => false
      case AddIntLit8(a, b, c) => false
      case RsubIntLit8(a, b, c) => false
      case MulIntLit8(a, b, c) => false
      case DivIntLit8(a, b, c) => false
      case RemIntLit8(a, b, c) => false
      case AndIntLit8(a, b, c) => false
      case OrIntLit8(a, b, c) => false
      case XorIntLit8(a, b, c) => false
      case ShlIntLit8(a, b, c) => false
      case ShrIntLit8(a, b, c) => false
      case UshrIntLit8(a, b, c) => false
      case AddIntLit16(a, b, c) => false
      case RsubInt(a, b, c) => false
      case MulIntLit16(a, b, c) => false
      case DivIntLit16(a, b, c) => false
      case RemIntLit16(a, b, c) => false
      case AndIntLit16(a, b, c) => false
      case OrIntLit16(a, b, c) => false
      case XorIntLit16(a, b, c) => false
      case CheckCast(a, b) => false
      case NewInstance(a, b) => false
      case InstanceOf(a, b, c) => false
      case IGet(a, b, c) => false
      case IGetWide(a, b, c) => false
      case IGetObject(a, b, c) => false
      case IGetBoolean(a, b, c) => false
      case IGetByte(a, b, c) => false
      case IGetChar(a, b, c) => false
      case IGetShort(a, b, c) => false
      case IPut(a, b, c) => false
      case IPutWide(a, b, c) => false
      case IPutObject(a, b, c) => false
      case IPutBoolean(a, b, c) => false
      case IPutByte(a, b, c) => false
      case IPutChar(a, b, c) => false
      case IPutShort(a, b, c) => false
      case SGet(a, b) => false
      case SGetWide(a, b) => false
      case SGetObject(a, b) => false
      case SGetBoolean(a, b) => false
      case SGetByte(a, b) => false
      case SGetChar(a, b) => false
      case SGetShort(a, b) => false
      case SPut(a, b) => false
      case SPutWide(a, b) => false
      case SPutObject(a, b) => false
      case SPutBoolean(a, b) => false
      case SPutByte(a, b) => false
      case SPutChar(a, b) => false
      case SPutShort(a, b) => false
      case ArrayLength(a, b) => false
      case NewArray(a, b, c) => false
      case FillArrayData(a, size, elementWidth, data) => false
      case TempFillArrayData(a, b) => false
      case FilledNewArray(args, b) => false
      case FilledNewArrayRange(c, a, b) => false
      case AGet(a, b, c) => false
      case AGetWide(a, b, c) => false
      case AGetObject(a, b, c) => false
      case AGetBoolean(a, b, c) => false
      case AGetByte(a, b, c) => false
      case AGetChar(a, b, c) => false
      case AGetShort(a, b, c) => false
      case APut(a, b, c) => false
      case APutWide(a, b, c) => false
      case APutObject(a, b, c) => false
      case APutBoolean(a, b, c) => false
      case APutByte(a, b, c) => false
      case APutChar(a, b, c) => false
      case APutShort(a, b, c) => false
      case PackedSwitchPayload(firstKey, targets) => false
      case SparseSwitchPayload(keys, targets) => false
      case FillArrayDataPayload(size, elementWidth, data) => false
      case _ => throw new Exception("unrecognized instruction: " + insn)
    }
  }
  
  override def processInstructions(methodProxy: MethodDefProxy)(method: MethodDef): Unit = {
    val t = new AnnotatedMethodDef(method.method, method.accessFlags, method.code)
    
  }

  def printTest {
    println("test");
  }
}
